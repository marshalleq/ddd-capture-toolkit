#!/usr/bin/env python3
"""
Check FSK Frame Boundaries

This script analyzes the actual sample boundaries generated by the 
pattern generator to identify timing misalignment issues.
"""

import numpy as np

def analyze_fsk_boundaries():
    """Analyze the FSK frame boundary calculations"""
    
    print("FSK Frame Boundary Analysis")
    print("=" * 40)
    
    # Parameters from the generator
    sample_rate = 48000
    fps = 25.0
    timecode_duration = 30.0
    
    # Calculate values
    samples_per_video_frame = sample_rate / fps  # 1920.0
    timecode_frames = int(timecode_duration * fps)  # 750
    timecode_start = 0  # Relative to timecode section
    
    print(f"Parameters:")
    print(f"  Sample rate: {sample_rate}Hz")
    print(f"  FPS: {fps}")
    print(f"  Samples per video frame: {samples_per_video_frame}")
    print(f"  Timecode frames: {timecode_frames}")
    
    print(f"\nFrame Boundary Analysis:")
    
    frame_sizes = []
    total_samples_used = 0
    
    for frame_idx in range(min(20, timecode_frames)):  # Check first 20 frames
        # This is the exact logic from the generator
        frame_start_exact = timecode_start + (frame_idx * samples_per_video_frame)
        frame_end_exact = timecode_start + ((frame_idx + 1) * samples_per_video_frame)
        
        # Convert to integer sample positions (PROBLEMATIC!)
        frame_start_int = int(round(frame_start_exact))
        frame_end_int = int(round(frame_end_exact))
        
        frame_size = frame_end_int - frame_start_int
        frame_sizes.append(frame_size)
        total_samples_used += frame_size
        
        print(f"  Frame {frame_idx:3d}: Start {frame_start_exact:8.1f} -> {frame_start_int:6d}, "
              f"End {frame_end_exact:8.1f} -> {frame_end_int:6d}, Size {frame_size}")
    
    print(f"\nFrame Size Statistics (first 20 frames):")
    print(f"  Frame sizes: {set(frame_sizes)}")
    print(f"  Average frame size: {np.mean(frame_sizes):.1f}")
    print(f"  Expected frame size: 1920")
    print(f"  Total samples used: {total_samples_used}")
    print(f"  Expected total: {20 * 1920}")
    
    # Check for gaps or overlaps
    print(f"\nGap/Overlap Analysis:")
    prev_end = 0
    for frame_idx in range(min(10, timecode_frames)):
        frame_start_exact = timecode_start + (frame_idx * samples_per_video_frame)
        frame_end_exact = timecode_start + ((frame_idx + 1) * samples_per_video_frame)
        
        frame_start_int = int(round(frame_start_exact))
        frame_end_int = int(round(frame_end_exact))
        
        if frame_idx > 0:
            gap = frame_start_int - prev_end
            if gap != 0:
                print(f"  Frame {frame_idx}: Gap/Overlap of {gap} samples")
        
        prev_end = frame_end_int
    
    # Show the correct approach
    print(f"\nCorrect Approach (Fixed Frame Size):")
    for frame_idx in range(min(10, timecode_frames)):
        frame_start_correct = frame_idx * 1920
        frame_end_correct = (frame_idx + 1) * 1920
        frame_size_correct = 1920
        
        print(f"  Frame {frame_idx:3d}: Start {frame_start_correct:6d}, "
              f"End {frame_end_correct:6d}, Size {frame_size_correct}")

if __name__ == "__main__":
    analyze_fsk_boundaries()
